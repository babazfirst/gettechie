---
sidebar_position: 5
title: Controllers
sidebar_label: 3 - Controllers
---

<!-- Imports -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Learn

A **controller** is the first place on HTTP request goes once it reaches your application. it is, in essence,  translator between the HTTP request and your code. In spring Boot, we use the '@RestController' annotation to tell spring that our clsss is  controller. 

Controller contain **endpoints**, which describe the URIs the cclient applicaion can acess. we use annotation for these as well, which we will discuss later on.

### What is JUnit?

[Junit](https://junit.org/junit5/) is a common java unit testing framework. It comes bundled with Intellij and  makes automting test cse simple.

### What is REST Assured?

[Rest Assured](http://rest-assured.io/) is a HTTP functional testing framework. It works by generating real HTTP request to an endpoint and allowing you to run asserions against the responses. 

---

:::note
Any code below with a package or import that includes 'bootcamp' as part of its path should replace 'bootcamp' with your project name.
:::

## Do

### 1. Create New Working Branch 

It is good practice when making changes to a git codebase to create nd work on  new branch so that your changes do not impact production code should they contain an error.
A new branch should be made off your primary branch for every new feature/modifiction.  

First, try to get the latest code to avoid merge coflicts and resolve if any.

```bash
git pull
```

Create a new local branch and switch to it executive the following command int the Intellij terminal: 

```bash
git checkout -b <branch>
```

where `<branch>` is the name of  new branch.

The 'checkout' command will move us to this new branch while the '-b' flag will create this branch for us should it not yet exist. We are now working on a new branch. 

### 2. Write 'Snack' object

Write the 'snack' **POJO** (**plain old Java object**) with a default constructor, parameterized constructor, and getters.

In the 'src/main/java/com.optum.`<your project name>` directory, create a new package called 'model'.

In the newly created package, create a new java class called 'Snack.java'.

Inclue private varibales 'id' and 'name', use Intellij to generate getters for those fields, and add 2 constructors in the class.

<Tabs
    groupId ="Snack"
    defaultValue="snippet"
    values={[
        {label: 'Code Snippet', value: 'snippet'},
        {label: 'Full Code', value: 'full'},
    ]}>
<TabItem value="snippet">

```java title="Snack.java"
public class Snack {

    private Integer id;
    private String name;

    public Snack() {}

    public Snack(Integer id, String name) {
        this.id = id;
        this.name = name;
    }
    ...
}
```

</TabItem>
<TabItem value="full">

If copying the full file you must replace the'bootcamp' path in the packge name and import to match your project name. 

```java title="Snack.java"
package com.optum.bootcamp.model;

public class Snack{
    private Integer id;

    private String name;

    public Snack() {}

    public Snack(Integer id, String name) {
        this.id = id;
        this.name;
    }

    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}
```

</TabItem>
</Tabs>

:::note
For those who are more familiar with java, the reason why we use the `Integer` class instead of the `int` primitive here will become clear later on.
:::

### 3. Write `SnackController`

Write the `SnackController` with one `GET` endpoint that will retrieve a single `Snack`.

In the `src/main/java/com.optum.<your project name>` directory, create a new package called `controller`.

In the newly created package, create a new Java class called `SnackController.java`.

Based on the annotation nd method header in the code snippet below, implement the `getSnackById` method to return  single `Snack` object. 

<Tabs
    groupId="SnackController"
    defaultValue="snippet"
    values={[
        {label: 'Code Snippet', value: 'snippet'},
        {label: 'Full Code', value: 'full'},
    ]}>
<TabItem value="snippet">

```java 
@GetMapping(
    value = "/v1/snacks/{snackId}",
    products = MediaType.APPLICATION_JSON_VALUE)
public Snack getSnackById(@PathVaribl("snackId") Integer id)
```
</TabItem>
    
<TabItem value="full">

If copying the full file you must replace the 'bootcamp' path in the package name imports to match your project name. 

```java
package com.optum.bootcamp.controller;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVarible;
import org.springframework.web.bind.annotation.RestController;

import com.optum.bootcamp.model.Snack;

@RestController
public class SnackController {

    @GetMapping(value = "v1/snacks/{snackId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Snack getSnackById(@Pathvariable("snackId") Integer id) {
        return new Snack(id, "ButterFingers")
    }
}

```

</TabItem>
</Tabs>

We use the `@GetMapping` annotation to tell the controller that we want requests to the given HTTP `GET` endpoint to call the **handler methods** we describe. we call this a **mapping**.

There are two parameters in this annotation:

1. `value`, which tells the controller what the URI should look like; and 
2. `produces`, which tells the controller that the HTTP response it sends back to the client should be encoded as **JSON** (**JavaScript Object Notation**).

The String we pass to `value` is taced on to the end of the URI (hence, **endpoint**). Notice the braces (`{}`) in the string. These braces denote a variable in the URI. Each of our `Snack` objects will be given a unique ID, and if we use this ID in our HTTP request, the controller will parse it and asign its value to a parameter in the method call. we do this with the `@PathVariable` annotation you can see in the method header. 

For example, if you wanted to retrieve the snack with ID 1, your request URL would look like: `http://localhost:8080/api/v1/snacks/1`. The application would then use the value `1` in its (hidden) call to `getSnackById()`. 

### 4. Write tests

Write a JUnit unit test and a REST Assured integration test for the `SnackControler`. 

#### Unit test 

  In the `src/test/java/co.optum.<your project name>` directory, create a new package called `controller`.

  In the newly created package, create a new Java class called `SnackControllerTest.java`. 

  Use the `@SpringBootTest` annotation to tell Spring Boot to start a Spring application context for the `@SpringBootApplication`, include a dependecy on `SnackController`, and use the `@Test` annotation to signify the method is a unit test. 

<Tabs
    groupId="SnackControllerTest"
    defaultValue="snippet"
    values={[
        {label: 'Code Snippet', value: 'snippet'},
        {label: 'Full Code', value: 'full'}
    ]}>
<TabItem value="snippet">

```java
@SpringBootTest
public class SnackControllerTest {

    @Autowired
    private SnackController snackController;

    @Test
    public void getSnackByIdTest() {
        ...
    }
    ...
}
```
</TabItem>

<TabItem value="full">

If copying the full file you mush replace the `bootcamp` path in the package name and imports to match your project name. 

```java 
package com.optum.bootcamp.controller;


import static org.assertj.core.api.Assertions.assertThan;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.ooptum.bootcamp.model.Snack;

@SpringBootTest 
public lass SnackControllerTest {

    @Autowired 
    private SnackController snackController;

    @Test
    public void getSnackByIdTest() {
        Integer id = 1;
        Snack snack = snackController.getSnackById(id);

        assertThat(snack.getId()).isEqual(id);
        assertThat(snack.getName()).isEqual("Butterfingers");
    }
}
```

</TabItem>
</Tabs>

To execute the unit tests, run the following command in the Intellij terminal: 

<Tabs
    groupId="operating-systems"
    defaultValue="win"
    values={[
        {label: 'Windows', value: 'win'},
        {label: 'MacOs', value: 'mac'},
    ]}>
<TabItem value="win">

```bash
.\gradlew test
```

</TabItem>

<TabItem value="mac">

```bash
./gradlew test
```

</TabItem>
</Tabs>


#### Integration test 

In the `srcc/intTest/java/com.optum.<your project name>` package, create a ew Java class caleed `SnackTest.java`. Note that a new package is NOT created in this case. 

Write a setup() method using the `@BeforeAll` annotation to configure testing parameters. 

Write a `genSnackTest()` method using the `@Test` annotation to integration test the `GET` endpoint. 

<Tabs
    groupId="SnackTest"
    defaultValue="snippet"
    values={[
        {label: 'Code Snippet', value: 'snippet'},
        {label: 'Full Code', value: 'full'},
    ]}>
<TabItem value="snippet">

```java
public class SnackTest {

    @BeforeAll
    static void setup() {
        RestAssured.baseURI = Config.baseURI;
        RestAssured.port = Config.port;
        RestAssured.userRelaxedHTTPSValidation();
    }

    @Test
    public void getSnackTest() {
        ...
    }

}
```

</TabItem>

<TabItem value="full">

If copying the full file you must replace the'bootcamp' path in the packge name and import to match your project name. 

```java
package com.optum.bootcamp;

import static io.restassured.RestAssured.when;
import static org.hamcrest.Matchers.equalTo;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured;

public class SnackTest {

    @BeforeAll
    static void setup() {
        RestAssured.baseURI = Config.baseURI;
        RestAssured.port = Config.port;
        RestAssured.userRelaxedHTTPSValidation();
    }

    @Test
    public void getSnackTest() {
        Integer id = 1;
        String name = "Butterfingers";

        // Make the request and check that the response is what we expect 
        when()
            .get("/api/v1/snacks/{snackId}", id)
            .then()
            .assertThat()
            .statusCode(200)
            .body("id", equalTo(id))
            .body("name", equalTo(name));
    }
}
```

</TabItem>
</Tabs>

To execute the integration tests, you must first [rebuild and start up the Docker container](./running_on_Docker#do).

:::caution Important
If your Docker container is still running, make sure to shut it down prior to rebuilding it with:

```bash
docker-compose down 
```
:::

Once your container is up and running, runn the integration tests by executing the following command in the intelliJ terminal: 

<Tabs
    groupId="operating-system"
    defaultValue="win"
    values={[
        {label: 'Windows', value: 'win'},
        {label: 'MacOS', value: 'mac'},
    ]}>
<TabItem value='win'>

```bash
.\gradlew testIntegration
```

</TabItem>

<TabItem value='mac'>

```bash
./gradlew testIntegration
```

</TabItem>
</Tabs>


### 5. Debug

It is important to know how to debug, especially when trying to fix your tests that might be broken. In unit tests, it is as easy as setting breakpoints and start debugging. But in integration tests, you need to create a remote JVM debug configuration and attach debugger to process, because your application is running in Docker container, which is seen as a remote application. 

### 6. Commit and push changes 

Now that your changes have been made to the codebase, it is time to stage all of your changes for commiting by executing: 

```bash
git add . 
```

:::note
Using `.` will _add_ of your changed files to the commit. Sometimes, you may not want to add everything. In this case, you can instead provide the names of specific files or directories you wish to commit using: 

```bash
git add <file>
```

Alternatively, you can review all of the changes you made before adding them with the command:

```bash
git add --patch
```

:::

Now, commit your changes by executing:

```bash
git commit -m "<message>"
```

where `<message>` is your commit message describing your changes.

:::tip
It's common practice to wirte commit messages in the present tense rather than in the past tense (e.g. "Fix broken link" instead of "Fixed broken link").
Additionally, keep your commit messages as concise as possible. This [blog post by Chris Beams](https://chris.beams.io/posts/git-commit/) provides an in-depth discussion on the importance of good commit messages, as well as guidelines for writing good messages. 
:::


Finally, push your changes to a new remote branch in your Github repository by executing:

```bash
git push --set-upstream origin <branch>
```

where `<branch>` is your new branch name from before.

:::note
Intead of `--set-upstream`, you can also use the shorthand `-u` flag. It will achieve the same result. And this is usually needed the first time only. After that, you don't need this flag. 
:::

### 7. Open pull request 

In GitHub, open a pull request and select one or more individuals to review your changes. Provide additional comments as necessary. 

As sonn as you create the pull request, a new build in Jenkins will start. This build will build and test your new code and ensure that is passes quality gateways. If the build fails, you may need to go back and make changes to your code. 

### 8. Merge branch into `master`

After your code has been reviewed and the Jenkins build has completed successfully, you will be able to merge your code into `master` branch. After doing so, keeping in line with the [trunk-based branching strategy](https://test/com), you can safely delete the branch. 

After merging into `master` another Jenkins build will start to deploy your application to nonprod. 

### 9. Prepare for further development 

Now that the changes have been merged with the remote `master` branch, we need to update our local copy. To do so, first switch over to your local copy of `master` by executing the following command in the IntelliJ terminal: 

```bash
git checkout master 
```

Next, retrive your changes by execuring:

```bash
git pull 
```

You can also safely delete your old branch by execuring: 

```bash
git branch -d <branch>
```

where `<branch>` is the name of your branch from before. 

:::note
Sometimes, Git will watn your that there are uncommited changes on the branch your are truing to delete or that your local branch has not been fully merged. If, however, you know that all the correct changes have been committed, pushed, and merged successfully, you can use the `-D` flag (instead of `-d`) to force the brancch to be deleted.
:::

---